### Reverse Integer

---

>  [문제 링크](https://leetcode.com/problems/reverse-integer/)

### Math.abs(x)에 대하여

---

Math.abs(x) 메소드는 Integer.MIN_VALUE가 인자로 전달되면 그대로 Integer.MIN_VALUE를 반환

+ 이유 : Integer.MIN_VALUE = -2147483648 이 양수화 되면 2147483648이 나와야 하지만 이는 Integer가 표현할 수 있는 값의 범위를 넘어서기 때문

  + 부호 변경하기

    **2의 보수** = **1의 보수 + 1** = **비트 반전(~) + 1**

        -(-1) = (~(0xFFFFFFFF)) + 1 = 0x00000000 + 1 = 0x00000001 = 1

  + Integer.MIN_VALUE의 부호 변경 :

        -(Integer.MIN_VALUE) = (~(0x80000000)) + 1 = 0x7FFFFFFF + 1 



### 보수

---

+ 보수는 컴퓨터에서 음의 정수를 표현하기 위해서 고안됨

+ 컴퓨터는 사칙 연산을 할 때 덧셈을 담당하는 가산기(Adder)만 이용하기 때문에 컴퓨터의 뺄셈은 보수를 이용한 덧셈으로 구현됨

  ```
  // B의 보수 = -B
  A - B = A + (-B)
  ```

+ **보수**

  두 수의 합이 진법의 밑수(N)가 되게 하는 수

  혹은 N이 되기 위해 보충해줘야 하는 수

  ```
  10진수 4의 10의 보수 = 6
  10진수 2의 10의 보수 = 8
  ```

+ **1의 보수**

  이진수의 각 자리수가 1이 되기 위해 보충해줘야 하는 수

  = 각 자릿수가 모두 1인 수에서 주어진 2진수를 뺀 결과

  = **1의 보수** = **비트 반전**

  ```
   2진수 1010의 1의 보수 = 0101
  ```

+ 2의 보수

  어떤 수를 커다란 2의 제곱수에서 빼서 얻은 이진수

  ```
      100000000 (8+1=9자리) --> 256
    -) 01001011 (8자리) 		---> 75
    -----------
       10110101 (8자리) 		---> 181
  ```

  = **1의 보수 + 1**

  ```
       01001011 의 모든 자리의 수를 반전시킨다.
       10110100 (이것을 1의 보수라고 부른다)
                여기에 1을 더한다.
       10110100 ---> 180
    +) 00000001 ---> 1
    -----------
       10110101 ---> 181
  ```

  

  > 왜 음수를 표현하기 위해서 1의 보수가 아닌 2의 보수를 취했을까?

  1. 1의 보수를 이용하여 음수를 표현하면 0이 2개가 생김

  ```
  // 맨 왼쪽비트는 사인비트
  +0 : 0000 0000
  -0 : 1111 1111
  ```

  2. 이러한 문제를 해결하기 위해서 음수를 표현할 때는 2의 보수를 취하기로 한 것

  ```
  0000 0001 => 1111 1110 => (+1) => 1111 1111 == -1
  ```

  3. 그러므로 한 바이트의 범위는 -128 ~ 127이 되는 것

  

> 2의 보수로 음수를 표현했을 때

![twos_complement_wheel](../img/twos_complement_wheel.jpg?raw=true)



> 참고
>
> https://ndb796.tistory.com/4
>
> https://xn--ex3bt1ov9l.kr/17
>
> https://okky.kr/article/538686